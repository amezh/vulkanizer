#version 450

#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_16bit_storage: require
#extension GL_NV_mesh_shader: require
#extension GL_KHR_shader_subgroup_ballot: require

#include "constants.h"
#include "geometry.h"

layout(local_size_x = kShaderGroupSizeNV) in;

layout(binding = 0) readonly buffer Meshlets { Meshlet meshlets[]; };

taskNV out Task
{
	uint meshletIndices[kShaderGroupSizeNV];
} outTask;

layout (push_constant) uniform block
{
    Globals globals;
};

void main()
{
	uint threadIndex = gl_LocalInvocationID.x;
	uint groupIndex = gl_WorkGroupID.x;
	uint meshletIndex = kShaderGroupSizeNV * groupIndex + threadIndex;

	vec3 coneApex = (globals.model * vec4(
		meshlets[meshletIndex].center[0],
		meshlets[meshletIndex].center[1],
		meshlets[meshletIndex].center[2], 1.0)).xyz;
	
	vec3 coneAxis = (globals.model * vec4(
		int(meshlets[meshletIndex].coneAxis[0]) / 127.0,
		int(meshlets[meshletIndex].coneAxis[1]) / 127.0,
		int(meshlets[meshletIndex].coneAxis[2]) / 127.0, 1.0)).xyz;

	vec3 cameraPosition = globals.cameraPosition;
	float coneCutoff = int(meshlets[meshletIndex].coneCutoff) / 127.0;
	
	bool coneCulled =
		globals.enableConeCulling == 1 &&
		dot(normalize(coneApex - cameraPosition), coneAxis) >= coneCutoff;

	uvec4 coneCulledBallot = subgroupBallot(!coneCulled);
	
	if (!coneCulled)
	{
		uint subgroupLocalMeshletIndex = subgroupBallotExclusiveBitCount(coneCulledBallot);
		outTask.meshletIndices[subgroupLocalMeshletIndex] = meshletIndex;
	}
	
	if (threadIndex == 0)
	{
		uint visibleMeshletCount = subgroupBallotBitCount(coneCulledBallot);
		gl_TaskCountNV = visibleMeshletCount;
	}
}
