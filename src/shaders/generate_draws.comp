#version 450

#extension GL_EXT_control_flow_attributes: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_16bit_storage: require
#extension GL_KHR_shader_subgroup_ballot: require

#include "shader_common.h"

layout(local_size_x = kShaderGroupSizeNV) in;
layout(local_size_y = 1) in;
layout(local_size_z = 1) in;

layout(binding = 0) readonly buffer Meshes { Mesh meshes[]; };
layout(binding = 1) readonly buffer PerDrawDataVector { PerDrawData perDrawDataVector[]; };

layout(binding = 2) writeonly buffer DrawCommands { DrawCommand drawCommands[]; };
layout(binding = 3) writeonly buffer DrawCount { uint drawCount; };

layout (push_constant) uniform block
{
    PerFrameData perFrameData;
};

shared uint drawOffset;

void main()
{
	uint groupThreadIndex = gl_LocalInvocationID.x;
	uint drawIndex = gl_GlobalInvocationID.x;

	PerDrawData perDrawData = perDrawDataVector[drawIndex];
	Mesh mesh = meshes[perDrawData.meshIndex];
	
	vec3 center = (perDrawData.model * vec4(
		mesh.center[0],
		mesh.center[1],
		mesh.center[2], 1.0)).xyz;
		
	bool visible = drawIndex < perFrameData.maxDrawCount;

	if (visible)
	{
		bool frustumCulled = false;

		[[unroll]]
		for(int i = 0; i < 6; ++i)
		{
			frustumCulled = frustumCulled ||
				dot(vec4(center, 1.0), perFrameData.frustumPlanes[i]) + mesh.radius < 0.0;
		}

		frustumCulled = frustumCulled && perFrameData.enableMeshFrustumCulling == 1;
		visible = !frustumCulled;
	}

	uvec4 visibleBallot = subgroupBallot(visible);
	uint visibleMeshCount = subgroupBallotBitCount(visibleBallot);

	if (groupThreadIndex == 0)
	{
		drawOffset = atomicAdd(drawCount, visibleMeshCount);
	}

	subgroupMemoryBarrierShared();

	float meshToCameraDistance = distance(center, perFrameData.cameraPosition);
	uint lodIndex = uint(max(1.0 +
		log(meshToCameraDistance / perFrameData.lodTransitionBase) /
		log(perFrameData.lodTransitionStep), 0.0));

	lodIndex = perFrameData.forcedLod < 0 ?
		min(lodIndex, mesh.lodCount - 1) :
		min(perFrameData.forcedLod, mesh.lodCount - 1);

	MeshLod meshLod = mesh.lods[lodIndex];
	
	uint visibleMeshIndex = subgroupBallotExclusiveBitCount(visibleBallot);

	if (visible)
	{
		DrawCommand drawCommand;
		drawCommand.indexCount = meshLod.indexCount;
		drawCommand.instanceCount = 1;
		drawCommand.firstIndex = meshLod.firstIndex;
		drawCommand.vertexOffset = mesh.vertexOffset;

		drawCommand.firstInstance = 0;
		drawCommand.taskCount = (meshLod.meshletCount + kShaderGroupSizeNV - 1) / kShaderGroupSizeNV;
		drawCommand.firstTask = 0;

		drawCommand.drawIndex = drawIndex;
		drawCommand.lodIndex = lodIndex;
		
		uint drawCommandIndex = drawOffset + visibleMeshIndex;
		drawCommands[drawCommandIndex] = drawCommand;
	}
}
